#include <iostream>
#include <string>
#include <vector>
#include <stdlib.h>
#include <time.h>

using namespace std;

//Текстовые функции

void HelloNewGame() {
	cout << "************************************************************\n"
		<< "*                     И Г Р А    Н И М                     *\n"
		<< "*     Вы можете взять любое число фишек из любого ряда     *\n"
		<< "*       Выигрывает тот, кто возьмет последнюю фишку.       *\n"
		<< "*             Введите настройки игры в формате             *\n"
		<< "* КОЛИЧ_СТРОК     (макс 9)     КОЛИЧ_ФИШЕК_В_ПЕРВОЙ_СТРОКЕ *\n"
		<< "*             (3 3 для классической игры НИМ)              *\n"
		<< "*            Или введите 0 0 для выхода из игры            *\n"
		<< "************************************************************\n"
		<< "Ожидание ввода:\n";
}

void Interface(const vector<int>& map) {
	cout << "************************************************************\n"
		<< "*                     И Г Р А    Н И М                     *\n"
		<< "*     Вы можете взять любое число фишек из любого ряда     *\n"
		<< "*       Выигрывает тот, кто возьмет последнюю фишку.       *\n"
		<< "* Номер ряда                                  Кол-во фишек *\n";
	for (int i = 0; i < map.size(); ++i) {
		string tokens(map[i], '*');
		string spaces(32 - map[i], ' ');
		cout << "*      " << i + 1 << "            " << tokens << spaces << map[i] << "      *\n";
	} // Выводим по отдельности индекс и кол-во фишек в строке
	cout << "*      Введите ваш ход в формате РЯД КОЛИЧ (например,      *\n"
		<< "*              2 3 - взять из 2 ряда 3 фишки)              *\n"
		<< "*            Или введите 0 0 для выхода из игры            *\n"
		<< "************************************************************\n"
		<< "Ваш ход:\n";
}

void Win() {
	cout << "************************************************************\n"
		<< "*                       Вы выиграли!                       *\n"
		<< "*                 Чтобы начать новую игру,                 *\n"
		<< "*             введите настройки игры в формате             *\n"
		<< "* КОЛИЧ_СТРОК                  КОЛИЧ_ФИШЕК_В_ПЕРВОЙ_СТРОКЕ *\n"
		<< "*             (3 3 для классической игры НИМ)              *\n"
		<< "*            Или введите 0 0 для выхода из игры            *\n"
		<< "************************************************************\n"
		<< "Ожидание ввода:\n";
}

void Lose() {
	cout << "************************************************************\n"
		<< "*                      Вы проиграли!                       *\n"
		<< "*                 Чтобы начать новую игру,                 *\n"
		<< "*             Введите настройки игры в формате             *\n"
		<< "* КОЛИЧ_СТРОК                  КОЛИЧ_ФИШЕК_В_ПЕРВОЙ_СТРОКЕ *\n"
		<< "*             (3 3 для классической игры НИМ)              *\n"
		<< "*            Или введите 0 0 для выхода из игры            *\n"
		<< "************************************************************\n"
		<< "Ожидание ввода:\n";
}

// Функциональныe функции

void InTurn(int& MoveRow, int& MoveCum) {
	string Cum;
	vector<int> NumStr_FirstRow = { 0, 0 };
	int flag = 0;
	getline(cin, Cum);
	for (char i : Cum)
	{
		switch (flag)
		{
		case(0):
			if (isdigit(i)) {
				NumStr_FirstRow[0] *= 10;
				NumStr_FirstRow[0] += int(i) - '0';
			}
			else {
				flag++;
			}
			break;
		case(1):
			if (isdigit(i)) {
				NumStr_FirstRow[1] *= 10;
				NumStr_FirstRow[1] += int(i) - '0';
			}
			else {
				flag++;
			}
			break;
		default:
			NumStr_FirstRow[0] = 0;
			NumStr_FirstRow[1] = 0;
			break;
		}
	}
	MoveRow = NumStr_FirstRow[0];
	MoveCum = NumStr_FirstRow[1];
}

void InSettings(int& NumStr, int& FirstRow) {
	string Cum;
	vector<int> NumStr_FirstRow = { 0, 0 };
	int flag = 0;
	getline(cin, Cum);
	for (char i : Cum)
	{
		switch (flag)
		{
		case(0):
			if (isdigit(i)) {
				NumStr_FirstRow[0] *= 10;
				NumStr_FirstRow[0] += int(i) - '0';
			} else {
				flag++;
			}
			break;
		case(1):
			if (isdigit(i)) {
				NumStr_FirstRow[1] *= 10;
				NumStr_FirstRow[1] += int(i) - '0';
			}
			else {
				flag++;
			}
			break;
		default:
			NumStr_FirstRow[0] = 0;
			NumStr_FirstRow[1] = 0;
			break;
		}
	}
	NumStr = NumStr_FirstRow[0];
	FirstRow = NumStr_FirstRow[1];
}

void NewGame(vector<int>& map) {
	int NumStr, FirstRow; // Генерируем поле игры с увеличивающимися строками символов
	InSettings(NumStr, FirstRow);
	for (int i = 0; i < NumStr; ++i) {
		map.push_back(FirstRow + i);
	}
}

void Moving(vector<int>& map, int start) {
	vector<int> result; // Удаление пустой строки
	for (int i = 0; i < map.size(); ++i) {
		if (i != start) {
			result.push_back(map[i]);
		}
	}
	map = result;
}

//Функции мувов
void Player_move(vector<int>& map, int MoveRow, int MoveCum) {
	if (map[MoveRow - 1] < MoveCum) {
		cout << "Неправильный ввод!\n";
	}
	else if (map[MoveRow-1] == MoveCum) {
		Moving(map, MoveRow - 1);
	}
	else {
		map[MoveRow - 1] -= MoveCum;
	}
}

void Bot_move(vector<int>& map) {
	int Nim_Num = 0, losei = 0, losej = 0;
	vector<int> TechMap = map; // Временный вектор, на котором тестируются мувы
	for (int i = 0; i < map.size(); ++i) {
		for (int j = 0; j < map[i]; ++j) { // Выбор мува - i строка, j - кол-во забираемых
			TechMap[i] -= j; // Делает мув
			for (int k : map) {
				Nim_Num ^= k;
			} // Считает Ним-Число для этого мува
			if (Nim_Num == 0) { // Если мув выигрышный
				if (map[i] == j) {
					Moving(map, i);
				}
				else {
					map[i] -= j;
				} // Удаляем строку или вычитаем из неё
				goto exit_excellent; // И выходим из функции
			}
			TechMap = map; // Если мув не нашелся, обнуляем временный вектор
		}
	} // Если выигрышный мув не нашелся
	losei = rand() % map.size(); // Случайная строка
	losej = rand() % map[losei]; // Случайное число фишек
	if (map[losei] == losej) {
		Moving(map, losei);
	}
	else {
		map[losei] -= losej; // Случайный мув
	}
exit_excellent:;

}

int main() { //Начало
	srand(time(NULL));
	vector<int> map;
	int MoveRow, MoveCum;

	HelloNewGame();
	NewGame(map);
	Interface(map);
	InTurn(MoveRow, MoveCum);

	while ((MoveRow != 0) && (MoveCum != 0)) { // Пока игрок не закроет игру вводом 0 0
		Player_move(map, MoveRow, MoveCum);
		if (map.empty()) { // Игрок победил
			Win();
			NewGame(map);
			Interface(map);
		} 
		else {
			Bot_move(map);
			if (map.empty()) { // Бот победил
				Lose();
				NewGame(map);
				Interface(map);
			}
			else { // Иначе игра продолжается
				Interface(map);
			}
		}
		InTurn(MoveRow, MoveCum);
	}
}